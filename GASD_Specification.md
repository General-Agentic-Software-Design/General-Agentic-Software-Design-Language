# GASD 1.0.0 — Official Authoritative General Agentic Software Design Language GASD

## 1. Introduction

GASD is a **Design Bridge Language**. It sits between upstream requirements — whether a formal SRS (Software Requirements Specification) or Agile User Stories — and transpiled implementation code. GASD captures *HOW to architect and constrain* a system — with enough precision that an AI agent generates **consistent, identical code every time**. 

This specification is **Compliant with RFC 2119** terminology.

```
SRS / User Stories  →  GASD (Design Bridge)  →  Transpiled Code
  "What is needed"      "How to architect it"     "Runnable output"
                        + constraints for
                        deterministic generation
```

**GASD does NOT contain:**
- Requirements (handled by SRS or User Stories upstream)
- Implementation code (generated by transpiler downstream)

**GASD DOES contain:**
- Design decisions, component architecture, type contracts
- Enough constraints to eliminate agent interpretation variance

### 1.1 Agile & User Story Coexistence
For GASD to coexist with user-story driven development (Agile), it must not replace user stories — it must sit downstream of them. With GASD, you insert a deterministic design bridge:

`Epic` → `User Stories` → `Acceptance Criteria` → `SRS` (optional formalization layer) → `GASD` (deterministic architecture spec) → `Transpiled Code`

- **SRS or User Stories define behavior.**
- **GASD removes architectural degrees of freedom.**

By strictly separating these concerns, GASD makes code generation:
1.  **Deterministic**
2.  **Stable**
3.  **Reproducible**
4.  **Testable**
5.  **Versionable**

### 1.2 Compliance & Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

- **MUST**: This word, or the terms "REQUIRED" or "SHALL", mean that the definition is an absolute requirement of the specification.
- **MUST NOT**: This phrase, or the phrase "SHALL NOT", mean that the definition is an absolute prohibition of the specification.
- **SHOULD**: This word, or the adjective "RECOMMENDED", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.
- **MAY**: This word, or the adjective "OPTIONAL", mean that an item is truly optional.

#### 1.2.1 Determinism Conformance
A GASD Transpiler **MUST** produce identical output for the same GASD source and target platform. Any variance in the generated implementation **SHALL** be considered a violation of the GASD 1.0.0 specification.

---

## 2. File Structure

A GASD file is a **plain text** file, typically using **UTF-8** encoding. It is organized into sections:

1. **Context & Directives** — Generation targets and global settings
2. **Decisions** — Locked-down architectural choices
3. **Types & Contracts** — Data definitions with constraint annotations
4. **Components & Interfaces** — Architectural building blocks
5. **Flows** — Design-level logic
6. **Strategies** — Algorithmic specifications
7. **Constraints & Invariants** — Cross-cutting rules


---

## 2.1 Comments

GASD supports both single-line and block comments to annotate designs without affecting transpilation.

### Syntax
- **Single-line**: Starts with `//`. Ignored by transpiler.
- **Block**: Enclosed between `/*` and `*/`. Ignored by transpiler.
- **Documentation**: Starts with `///`. Used to generate external documentation (API reference, SRS traceability matrix).

```gasd
/// Represents a user in the system.
/// @trace SRS-001
TYPE User: ...
```
```
/* 
   This is a block comment.
   It can span multiple lines to explain
   complex design rationale.
*/
```

---

## 3. Context & Directives

Global settings that inform the transpiler and link to upstream requirements.

### Formal Syntax
- **Directives**: `[DIRECTIVE]: "[Value]"`
- **Imports**: `IMPORT "[File Path]"` or `IMPORT "[File Path]" AS [Alias]`
- **Namespace**: `NAMESPACE: "[Dot.Separated.Path]"`
- **Annotations**: `@[Identifier]` or `@[Identifier]("[Value]")`

A GASD file **MUST** begin with the `CONTEXT` and `TARGET` directives. The `NAMESPACE` directive **SHOULD** be provided to ensure logical grouping.

1. **`NAMESPACE`** — Defines the logical grouping for the types/components in this file.
   - `NAMESPACE: "com.acme.payment"`

2. **`IMPORT`** — Includes definitions from another GASD file.
   - `IMPORT "common/types.gasd"`
   - `IMPORT "payment_service.gasd" AS Payment`

3. **`TRACE`** — Links a design block or the entire file to upstream artifacts. Supports any traceable identifier — SRS requirements, User Stories, Epics, or Acceptance Criteria.

```gasd
CONTEXT: "Spring Boot microservice"
TARGET: "Java 17"

// SRS-driven tracing
TRACE: "SRS-101", "SRS-115"

// User Story / Agile tracing
TRACE: "EPIC-007", "US-042", "AC-042-1"

@injectable UserRepository
@mockable PaymentGateway
@optimize("minimize memory usage")
```

| Directive | Effect on Generation |
|---|---|
| `CONTEXT` | Informs framework/library choices |
| `TARGET` | Locks target language/version |
| `@injectable` | Generates DI-compatible constructors |
| `@mockable` | Generates interface abstractions for testing |
| `@optimize(...)` | Guides performance-related code choices |

---

## 4. Design Decisions — `DECISION`

Captures architectural choices that **lock down** how the agent generates code. Prevents drift between transpilations.

### Formal Syntax
```gasd
DECISION "[Decision Name]" [Annotations]:
    CHOSEN: "[Choice]"
    RATIONALE: "[Reasoning]"
    [ALTERNATIVES: ["[Alt1]", "[Alt2]"]]
    AFFECTS: [[Element1], [Element2]] | [*]
```

```gasd
DECISION "Password Storage":
    CHOSEN: "bcrypt"
    RATIONALE: "Industry standard, available in all target languages"
    AFFECTS: [User.password_hash, AuthService.register]

DECISION "Error Strategy":
    CHOSEN: "Exception-based"
    ALTERNATIVES: ["Error codes", "Result monad"]
    AFFECTS: [*]
```

**Why this matters**: Without `DECISION`, the agent might choose bcrypt one day and argon2 the next. The `DECISION` block eliminates this variance.

---

## 5. Types & Contracts — `TYPE`

Strict type definitions with **constraint annotations** that drive code generation. Each annotation translates to specific validation logic in the output.

### Formal Syntax
```gasd
TYPE [Type Name] [Annotations]:
    [Field Name]: [Primitive|Custom Type] [Annotations]
    ...
```

```gasd
TYPE RequestData:
    email: String
        @format("email")                    // → email regex validation
        @unique(scope: UserRepository)      // → uniqueness check generated
    password: String
        @min_length(8)                      // → length guard
        @constraint("must contain uppercase and number")
    age: Integer
        @range(18, 150)                     // → bounds check

TYPE UserProfile:
    id: UUID
    username: String @unique
    tags: List<String>
    metadata: Map<String, Any>
    created_at: DateTime @auto_generate
```

### Abstract Data Type Mapping

| GASD Type | Java | Python | C++ | Rust |
|---|---|---|---|---|
| `String` | `String` | `str` | `std::string` | `String` |
| `Integer` | `int` | `int` | `int` | `i32` |
| `List<T>` | `ArrayList<T>` | `list[T]` | `std::vector<T>` | `Vec<T>` |
| `Map<K,V>` | `HashMap<K,V>` | `dict[K,V]` | `std::unordered_map<K,V>` | `HashMap<K,V>` |
| `UUID` | `UUID` | `uuid.UUID` | `std::string` | `Uuid` |
| `DateTime` | `Instant` | `datetime` | `std::chrono::time_point` | `DateTime<Utc>` |
| `Result<T>` | `Result<T>` | `Union[T, Error]` | `std::expected<T, E>` | `Result<T, E>` |
| `Float` | `Double` | `float` | `double` | `f64` |
| `Boolean` | `boolean` | `bool` | `bool` | `bool` |
| `Decimal` | `BigDecimal` | `Decimal` | `std::decimal` | `Decimal` |
| `Bytes` | `byte[]` | `bytes` | `std::vector<uint8_t>` | `Vec<u8>` |
| `Any` | `Object` | `Any` | `std::any` | `Box<dyn Any>` |
| `Void` | `void` | `None` | `void` | `()` |

---


### 5.1 Strict Type Semantics

To ensure cross-language determinism, GASD types represent **Behavioral Contracts**, not just storage.

| Type | Behavioral Contract | Transpiler Guarantee |
|---|---|---|
| **`Integer`**| Signed 64-bit safe numbers. | **MUST** handle overflow or use BigInt if `@range` exceeds 2^63. |
| ****`Float`** | IEEE 754 Double Precision. | Used for approximations. **MUST NOT** be used for Financial/Money logic. |
| ****`Decimal`**| Fixed-point arithmetic. | **MUST** be used for exact precision (Financial). |
| ****`Boolean`**| True/False logic. | Strict boolean. **SHALL NOT** use truthy/falsy coercion. |
| ****`String`** | UTF-8 Text Sequence. | **SHALL** guarantee valid UTF-8. Length checks **MUST** operate on unicode characters. |
| ****`Bytes`** | Raw sequence of uint8. | Used for binary payloads. Length checks **MUST** operate on byte count. |
| ****`UUID`** | 128-bit Unique ID. | **MUST** be canonically represented as 36-char string (RFC 4122). |
| ****`DateTime`**| ISO 8601 Timestamp. | **SHALL** be stored as UTC. |
| ****`Result<T>`**| Success/Failure Monad. | **MUST** force explicit error handling. |
| ****`Void`** | Unit / Empty. | Function returns nothing. |
| ****`Any`** | Dynamic / Unsafe. | Type safety is explicitly opted-out. |

---

## 6. Components & Interfaces — `COMPONENT`, `INTERFACE`

Defines architectural building blocks and their contracts.

### Formal Syntax
```gasd
COMPONENT [Name] [Annotations]:
    PATTERN: "[Pattern Name]"
    DEPENDENCIES: [[Dependency List]]
    INTERFACE:
        [Method Name]([Arg]: [Type], ...) -> [Return Type] [Annotations]
```

```gasd
COMPONENT AuthService:
    PATTERN: "Repository"
    DEPENDENCIES: [UserRepository, EmailService, PaymentGateway]
    INTERFACE:
        register(request_data: RequestData) -> String
        login(email: String, password: String) -> SessionToken

COMPONENT UserRepository:
    PATTERN: "Repository"
    INTERFACE:
        find_by_email(email: String) -> Optional<User>
        save(user: User) -> Void
```

---

## 7. Design Flows — `FLOW`

Expresses **design-level logic** — not code, but structured steps with enough constraint annotations to guarantee consistent transpilation.

### Formal Syntax
```gasd
FLOW [Name]([Args]): [Return Type] [Annotations]:
    [Step Number]. [PRIMITIVE] [Target] [OnCondition] [Annotations]
    [CREATE [Obj]: [Assignment], ...]
```

```gasd
FLOW register_new_customer(request_data: RequestData) -> String:
    @pattern("Service Method")
    @error_strategy("Exception-based")

    1. VALIDATE request_data
    2. ENSURE uniqueness(request_data.email)
        OTHERWISE THROW ConflictException("User already exists")
    3. ACHIEVE "Create payment customer"
        ON_ERROR: THROW BadGatewayException("Payment provider failed")
    4. CREATE User:
        password_hash = TRANSFORM(request_data.password, @hash("bcrypt"))
        payment_id = result_of(step 3)
        role = "CUSTOMER"
    5. PERSIST User via UserRepository
    6. ACHIEVE "Send Welcome Email" @async
    7. RETURN User.id
```

### Flow Keywords

| Keyword | Purpose | Determinism Effect |
|---|---|---|
| `VALIDATE` | Triggers validation from TYPE constraints | Agent uses exact annotations |
| `ENSURE ... OTHERWISE` | Guard clause with specified error | Exact error type/message |
| `ACHIEVE` | High-level goal (agent fills logic) | Constrained by DECISION blocks |
| `CREATE` | Object construction | Fields locked by TYPE contract |
| `PERSIST` | Storage operation | Uses specified repository |
| `TRANSFORM` | Data transformation with annotation | `@hash("bcrypt")` → exact impl |
| `@async` | Execution mode | Agent generates async code |
| `ON_ERROR` | Error handling directive | Exact error type generated |

---

## 8. Algorithmic Strategy — `STRATEGY`

When an algorithm matters for consistency, specify the approach without writing code.

### Formal Syntax
```gasd
STRATEGY [Name] [Annotations]:
    ALGORITHM: "[Algorithm Description]"
    [PRECONDITION: [Condition]]
    [COMPLEXITY: [BigO]]
    INPUT: [Arg]: [Type], ...
    OUTPUT: [Type]
```

```gasd
STRATEGY binary_search:
    ALGORITHM: "Iterative binary search"
    PRECONDITION: input IS_SORTED
    COMPLEXITY: O(log n) time, O(1) space
    INPUT: sorted_list: List<Comparable>, target: Comparable
    OUTPUT: Integer    // index or -1 if not found

STRATEGY sort_users:
    ALGORITHM: "Stable sort"
    SORT_KEY: User.created_at
    ORDER: ASCENDING
```

**Why this matters**: Without `STRATEGY`, the agent might generate recursive binary search one time and iterative the next. The `ALGORITHM` field eliminates this variance.

---

## 9. Constraints & Invariants

Rules the generated code **MUST** obey globally. A Transpiler **SHALL** validate these constraints during the design-time check.

```gasd
CONSTRAINT: "Use Dependency Injection for all external services"
CONSTRAINT: "All public methods must have input validation"
INVARIANT: "Account balance must never be negative"
ENSURE: "All database operations are within a transaction"
```

### Testability Constraints
```gasd
@testable          // Function must be pure or mockable
@injectable DB     // DI-compatible
@mockable Gateway  // Interface abstraction for testing
```

---

## 10. Human-in-the-Loop — `QUESTION`, `APPROVE`

Primitives for the AI-human design review cycle.

### Formal Syntax
```gasd
QUESTION: "[Text]"
    [BLOCKING: [Boolean]]
    [CONTEXT: [Reference]]

APPROVE "[Target Decision/Block]":
    STATUS: [APPROVED | REJECTED]
    BY: "[Reviewer Name]"
    DATE: "[ISO Date]"
    [NOTES: "[Text]"]
```

### Lifecycle & Status
Annotations to track the maturity of a design element. Used by humans to approve agent-generated drafts.

- `@status("DRAFT")` — Initial agent generation
- `@status("REVIEW_REQUIRED")` — Flagged for architect review
- `@status("APPROVED")` — Locked for code generation

### Agent Rationale
When an agent generates GASD from an SRS, it uses these to explain its design choices.

- `@heuristic("Reasoning")` — The architectural rule-of-thumb applied
- `@agent_note("Context")` — Specific assumption made from the SRS

```gasd
COMPONENT AuthService @status("REVIEW_REQUIRED"):
    @agent_note("Selected Repository pattern because SRS-201 requires decoupling")
    PATTERN: "Repository"
```

### Questions & Approvals
```gasd
// Agent can ask
QUESTION: "Should we support OAuth2 social login?"
    BLOCKING: true
    CONTEXT: AuthService.register

// Human approves design decisions
APPROVE "Password Storage":
    STATUS: APPROVED
    BY: "Lead Architect"
    DATE: "2026-02-15"
    NOTES: "bcrypt is acceptable for MVP"

// Human review markers
TODO: "Add rate limiting logic in v2"
REVIEW: "Check if this handles race conditions"
```

---

## 11. Pattern Matching — `MATCH`

Deterministic branching construct.

### Formal Syntax
```gasd
MATCH [Expression]:
    [Pattern] -> [Outcome | Action]
    ...
    DEFAULT   -> [Fallback Outcome | Action]
```

```gasd
MATCH discount_code:
    "SummerSale" -> discount = base_price * 0.10
    "Welcome"    -> discount = 5.00
    DEFAULT      -> discount = 0
```

---

## 12. Cross-Language Compatibility

GASD is designed for transpilation to any major programming language.

### Supported Paradigms
- **Imperative/OO** (Python, Java, C#, C++, Swift, Go): Direct mapping of flows and types.
- **Scripting** (JavaScript, PHP, Ruby, Lua): Maps to dynamic typing and closures.
- **Systems** (Rust, C): Agent infers memory management from type contracts and constraints.
- **Functional** (Haskell, Scala, R): Flows transpiled to functional equivalents.

### Determinism Across Languages

The constraint system ensures that for the **same GASD file + same TARGET**, the output is identical:

```
GASD + TARGET:"Python" → always produces the same Python code
GASD + TARGET:"Java"   → always produces the same Java code
```

---

---

## 13. Standard Annotation Library

To ensure determinism, GASD recognizes a **Fixed Set** of annotations. Transpilers **MUST** support these standard annotations. Agents **MUST NOT** invent new annotations for functional logic.

### 13.1 Data Validation Constraints
Used on `TYPE` fields to generate validation logic.

| Annotation | Parameter | Effect on Code |
|---|---|---|
| `@range(min, max)` | `(Number, Number)` | Adds bound checks (e.g., `if (x < 18) throw`). |
| `@min_length(n)` | `(Integer)` | String/List minimum length check. |
| `@max_length(n)` | `(Integer)` | String/List maximum length check. |
| `@format(fmt)` | `("email"\|"uuid"\|"url")` | Validates against standard regex patterns. |
| `@unique` | `[ (scope: Target) ]` | Enforces uniqueness (DB constraint or set check). |
| `@default(val)` | `(Value)` | Sets default value if missing. |

### 13.2 Architectural Directives
Used on `COMPONENT` or Global Context to guide structure.

| Annotation | Parameter | Effect on Code |
|---|---|---|
| `@injectable` | `None` | component is registered in DI container. |
| `@mockable` | `None` | Generates interface + mock impl for testing. |
| `@optimize(goal)` | `(String)` | Heuristic for agent implementation strategy (e.g. "speed"). |
| `@transaction_type(t)` | `("SAGA"\|"ACID")` | Wraps flow in specific transaction manager. |

### 13.3 Implementation Modifiers
Used inside `FLOW` steps.

| Annotation | Parameter | Effect on Code |
|---|---|---|
| `@async` | `None` | Generates non-blocking/Promise-based code. |
| `@external` | `None` | Marks call as network boundaries (affects error handling). |
| `@error_strategy(s)` | `(String)` | Defines how errors are handled (e.g. "Fail-Fast", "Exception-based"). |
| `@algorithm(name)` | `(String)` | Selects specific algorithm (e.g. "bcrypt"). |
| `@hash(algo)` | `(String)` | Specific transformation instruction. |

### 13.4 Metadata & Lifecycle
Used for Human-AI collaboration (Ignored by Transpiler logic).

| Annotation | Parameter | Purpose |
|---|---|---|
| `@trace(id)` | `(String)` | Links to SRS requirement ID. |
| `@status(s)` | `("DRAFT"\|"APPROVED")` | Workflow state. |
| `@agent_note(txt)` | `(String)` | AI explanation of choices. |
| `@heuristic(txt)` | `(String)` | Algorithm selection reasoning. |

### 13.5 Extended Library (Common Standards)
These annotations are optional but highly recommended for production systems.

| Category | Annotation | Parameter | Effect |
|---|---|---|---|
| **Security** | `@sensitive` | `None` | Mask in logs, encrypt at rest. |
| | `@authorized(role)` | `(String)` | Adds role-based access control check. |
| | `@mask` | `None` | Obfuscates value in logs/UI. |
| **Resilience** | `@retry(n)` | `(Integer)` | Wraps call in retry logic. |
| | `@timeout(ms)` | `(Integer)` | Adds timeout constraint. |
| | `@circuit_breaker` | `None` | Protects against cascading failures. |
| **Observability**| `@metric(name)` | `(String)` | Records a business or technical metric. |
| | `@trace_id(val)` | `(Value)` | Correlates logs with a trace identifier. |
| **Caching** | `@cacheable(ttl)` | `(Integer)` | Caches result for TTL seconds. |
| | `@idempotent` | `None` | Safe to retry without side effects. |
| **Database** | `@index` | `None` | Adds DB index for performance. |
| | `@transient` | `None` | Field is not persisted. |
| **API** | `@deprecated` | `None` | Marks element for removal. |
| | `@rest(verb, path)` | `(Enum, String)` | Maps to HTTP endpoint. |

---

## Appendix A: Formal EBNF Grammar

The following is the formal Extended Backus-Naur Form (EBNF) grammar for GASD.

```ebnf
(* GASD Grammar *)

gasd_file     ::= { section }
section       ::= context_dir | namespace_stmt | import_stmt | decision_blk | type_def | component_def | flow_def | strategy_def | constraint

(* --- Context & Directives --- *)
context_dir   ::= ( "CONTEXT" | "TARGET" | "TRACE" ) ":" value { "," value }
namespace_stmt::= "NAMESPACE" ":" string_literal
import_stmt   ::= "IMPORT" string_literal [ "AS" identifier ]
value         ::= string_literal | number_literal | boolean_literal

(* --- Decisions --- *)
decision_blk  ::= "DECISION" string_literal [ annotations ] ":" indent
                  "CHOSEN" ":" string_literal
                  [ "RATIONALE" ":" string_literal ]
                  [ "AFFECTS" ":" list_literal ]
                  dedent

(* --- Types --- *)
type_def      ::= "TYPE" identifier [ annotations ] ":" indent
                  { field_def }
                  dedent

field_def     ::= identifier ":" type_expr [ annotations ]

type_expr     ::= identifier
                | "List" "<" type_expr ">"
                | "Map" "<" type_expr "," type_expr ">"
                | "Enum" "(" identifier { "," identifier } ")"
                | "Optional" "<" type_expr ">"

(* --- Components --- *)
component_def ::= "COMPONENT" identifier [ annotations ] ":" indent
                  [ "PATTERN" ":" string_literal ]
                  [ "DEPENDENCIES" ":" list_literal ]
                  "INTERFACE" ":" indent
                  { method_sig }
                  dedent dedent

method_sig    ::= identifier "(" [ param_list ] ")" "->" type_expr

(* --- Flows --- *)
flow_def      ::= "FLOW" identifier "(" [ param_list ] ")" [ "->" type_expr ] ":" indent
                  { flow_step }
                  dedent

flow_step     ::= step_number "." ( action | control_flow )

action        ::= "VALIDATE" identifier
                | "ACHIEVE" string_literal [ block ]
                | "CREATE" identifier ":" block
                | "PERSIST" identifier "via" identifier
                | "RETURN" expr
                | "LOG" string_literal

control_flow  ::= "ENSURE" condition [ "OTHERWISE" action ]
                | "MATCH" expr ":" indent { match_case } dedent
                | "IF" condition ":" indent { flow_step } dedent [ "ELSE" ":" indent { flow_step } dedent ]
                
match_case    ::= ( string_literal | "DEFAULT" ) "->" flow_step

block         ::= indent { property | annotation | flow_step } dedent
property      ::= identifier ":" value

value         ::= string_literal | number_literal | boolean_literal | identifier | expr

expr          ::= identifier { "." identifier } [ "(" [ arg_list ] ")" ]
arg_list      ::= value { "," value }

(* --- Lexical Tokens --- *)
identifier    ::= [a-zA-Z_] { [a-zA-Z0-9_.] }
string_literal::= '"' { character } '"'
indent        ::= (* implied indentation increase *)
dedent        ::= (* implied indentation decrease *)
annotations   ::= "@" identifier [ "(" value ")" ] { "@" identifier [ "(" value ")" ] }
```

---

## Appendix B: Hello World Example

The most minimal GASD file possible, demonstrating basic structure.
```
CONTEXT: "General Software"
TARGET: "Any"
TRACE: "SRS-000 (Hello World)"

/* 
   A minimal Hello World example
   demonstrating basic component structure.

   --- Step-by-Step Breakdown ---
   1. Directives: CONTEXT and TARGET tell the transpiler this is a general-purpose design.
   2. Component Definition: COMPONENT Greeter creates a class/module named "Greeter".
   3. Interface: Defines the public method `say_hello` which returns a String.
   4. Flow: FLOW say_hello() provides the implementation logic—simply returning a literal string.
*/
COMPONENT Greeter:
    INTERFACE:
        say_hello() -> String

FLOW say_hello():
    1. RETURN "Hello, World!"

```
See: [examples/hello_world.gasd](examples/hello_world.gasd)


---

## Appendix C: Full Document Example

This example demonstrates a complete **User Management Service** using all GASD primitives in a single file.

See: [examples/user_management.gasd](examples/user_management.gasd)

